# PlantUML 클래스 다이어그램 가이드

## 클래스 간의 관계

클래스 간의 관계는 다음과 같은 기호를 사용하여 정의합니다 :

Extension <|--	extension symbol
Composition	*--	composition symbol
Aggregation	o--	aggregation symbol

`--`를 `..`로 변경하여 점선을 표현할 수 있습니다.

이러한 규칙을 이용하여, 다음과 같은 도면을 그릴 수 있습니다 :

```
@startuml
Class01 <|-- Class02
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 -- Class10
@enduml
```

@startuml
description - "class relation example"
Class01 <|-- Class02
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 -- Class10
@enduml

```
@startuml
Class11 <|.. Class12
Class13 --> Class14
Class15 ..> Class16
Class17 ..|> Class18
Class19 <--* Class20
@enduml
```

@startuml
description - "another class relation example"
Class11 <|.. Class12
Class13 --> Class14
Class15 ..> Class16
Class17 ..|> Class18
Class19 <--* Class20
@enduml

## 관계에 대한 레이블

`:` 뒤에 오는 text는 관계에 대한 레이블을 표시합니다. 관계의 양쪽 끝에 `""`를 사용하면 카디널리티(Cardinality)를 표시할 수 있습니다.

```
@startuml
Class01 "1" *-- "many" Class02 : contains
Class03 o-- Class04 : aggregation
Class05 --> "1" Class06
@enduml
```

@startuml
description - "label on class relation"
Class01 "1" *-- "many" Class02 : contains
Class03 o-- Class04 : aggregation
Class05 --> "1" Class06
@enduml

추가로 레이블의 시작이나 끝에 `<` 또는 `>`를 써서 오브젝트간의 행위의 방향을 표현할 수도 있습니다.

```
@startuml
class Car

Driver - Car : drives >
Car *- Wheel : have 4 >
Car -- Person : < owns

@enduml
```

@startuml
description - "directional arrow on class diagram"
class Car

Driver - Car : drives >
Car *- Wheel : have 4 >
Car -- Person : < owns

@enduml

## 메소드 추가

변수나 메소드를 선언하려면 `:` 뒤에 변수나 메소드의 이름을 적습니다. 시스템은 괄호를 체크하여 변수인지 메소드인지 판단합니다.

```
@startuml
Object <|-- ArrayList

Object : equals()
ArrayList : Object[] elementData
ArrayList : size()

@enduml
```

@startuml
description - "Put one field in classes"
Object <|-- ArrayList

Object : equals()
ArrayList : Object[] elementData
ArrayList : size()

@enduml

중괄호`{}`를 사용하여 모든 필드와 메소드를 그룹짓는 것도 가능합니다. 구문 내에서의 타입/이름의 순서는 매우 유연합니다.

```
@startuml
class Dummy {
  String data
  void methods()
}

class Flight {
  flightNumber : Integer
  departureTime : Date
}
@enduml
```

@startuml
description - "adding several fields/method in classes"
class Dummy {
  String data
  void methods()
}

class Flight {
  flightNumber : Integer
  departureTime : Date
}
@enduml

## 멤버의 가시성 정의

메소드나 변수를 정의 할 때 해당 항목의 가시성을 정의하는 문자를 사용할 수 있습니다 :

문자	| 가시성
----|------
- | private
# | protected
~	| package private
+ | public

```
@startuml

class Dummy {
  -field1
  #field2
  ~method1()
  +method2()
}

@enduml
```

@startuml
description - "defining field visibility"
class Dummy {
  -field1
  #field2
  ~method1()
  +method2()
}

@enduml

`skinparam classAttributeIconSize 0`를 사용하여 이 기능을 끌 수도 있습니다.

```
@startuml
skinparam classAttributeIconSize 0
class Dummy {
 -field1
 #field2
 ~method1()
 +method2()
}

@enduml
```

@startuml
description - "turning off visibility"
skinparam classAttributeIconSize 0
class Dummy {
 -field1
 #field2
 ~method1()
 +method2()
}

@enduml

## Abstract와 Static

`{static}` 이나 `{abstract}` 제어자(modifier)를 사용하여 추상(abstract) 메소드(변수)나 정적(static) 메소스(변수)를 정의할 수 있습니다. 이러한 제어자는 라인의 시작이나 끝에 둘 수 있으며 `{static}` 대신에 `{classifier}`를 사용해도 됩니다.

```
@startuml
class Dummy {
  {static} String id
  {abstract} void methods()
}
@enduml
```

@startuml
description - "static and abstract field method"
class Dummy {
  {static} String id
  {abstract} void methods()
}
@enduml

## 클래스의 고급 용법

기본적으로 메소드와 변수는 PlantUML이 자동으로 정렬해 주지만, `--..==__`와 같은 구분선(separator)를 사용하여 자신만의 방법으로 변수와 메소드의 순서를 정의할 수 도 있습니다. 

또한 구분선 내에서 제목을 사용할 수 도 있습니다:

```
@startuml
class Foo1 {
  You can use
  several lines
  ..
  as you want
  and group
  ==
  things together.
  __
  You can have as many groups
  as you want
  --
  End of class
}

class User {
  .. Simple Getter ..
  + getName()
  + getAddress()
  .. Some setter ..
  + setName()
  __ private data __
  int age
  -- encrypted --
  String password
}

@enduml
```

@startuml
description - "enhanced class body"
class Foo1 {
  You can use
  several lines
  ..
  as you want
  and group
  ==
  things together.
  __
  You can have as many groups
  as you want
  --
  End of class
}

class User {
  .. Simple Getter ..
  + getName()
  + getAddress()
  .. Some setter ..
  + setName()
  __ private data __
  int age
  -- encrypted --
  String password
}

@enduml

## 노트와 스테레오타입(stereotype)

스테레오타입은 클래스 키워드 `<<` 와 `>>`를 사용하여 정의합니다.

`note left of`, `note right of`, `note top of`, `note bottom of` 키워드를 사용하여 노트를 정의할 수 있습니다.

또한, 마지막으로 정의된 클래스 다음에 `note left`, `note right`, `note top`, `note bottom`을 사용하여 정의할 수도 있습니다.

노트는 `note` 키워드를 통해 단독으로 정의할 수 있으며, `..` 심볼을 이용하여 다른 오브젝트와 연결할 수 있습니다.

```
@startuml
class Object << general >>
Object <|--- ArrayList

note top of Object : In java, every class\nextends this one.

note "This is a floating note" as N1
note "This note is connected\nto several objects." as N2
Object .. N2
N2 .. ArrayList

class Foo
note left: On last defined class

@enduml
```

@startuml
description - "notes on class diagrams"
class Object << general >>
Object <|--- ArrayList

note top of Object : In java, every class\nextends this one.

note "This is a floating note" as N1
note "This note is connected\nto several objects." as N2
Object .. N2
N2 .. ArrayList

class Foo
note left: On last defined class

@enduml

## 노트에 대한 자세한 사항

노트에는 다음과 같은 몇몇 html 태그를 사용할 수 있습니다: 

* `<b>`
* `<u>`
* `<i>`
* `<s>`, `<del>`, `<strike>`
* `<font color="#AAAAAA">` or `<font color="colorName">`
* `<color:#AAAAAA>` 혹은 `<color:colorName>`
* `<size:nn>`: 폰트 사이즈 변경
* `<img src="file">` 혹은 `<img:file>`: 파일시스템에서 접근가능한 파일이어야 합니다

노트는 여러줄로 작성 가능합니다.

마지막으로 정의한 클래스 다음에 `note left`, `note right`, `note top`, `note bottom` 키워드를 이용하여 노트를 작성하면 해당 클래스의 노트가 작성됩니다.

```
@startuml

class Foo
note left: On last defined class

note top of Object
  In java, <size:18>every</size> <u>class</u>
  <b>extends</b>
  <i>this</i> one.
end note

note as N1
  This note is <u>also</u>
  <b><color:royalBlue>on several</color>
  <s>words</s> lines
  And this is hosted by <img:sourceforge.jpg>
end note

@enduml
```

@startuml
description - "advanced note options"
class Foo
note left: On last defined class

note top of Object
  In java, <size:18>every</size> <u>class</u>
  <b>extends</b>
  <i>this</i> one.
end note

note as N1
  This note is <u>also</u>
  <b><color:royalBlue>on several</color>
  <s>words</s> lines
  And this is hosted by <img:sourceforge.jpg>
end note

@enduml

## 링크에 노트 추가하기

링크에 노트를 추가하기 위해서는 링크 정의 바로 다음에서 `note on link`를 사용합니다.
`note left on link`, `note right on link`, `note top on link`, `note bottom on link` 을 사용하면 링크의 레이블에 대한 상대 위치로 노트가 정렬됩니다.

```
@startuml

class Dummy
Dummy --> Foo : A link
note on link #red: note that is red

Dummy --> Foo2 : Another link
note right on link #blue
	this is my note on right link
	and in blue
end note

@enduml
```

@startuml
description - "note on class links"
class Dummy
Dummy --> Foo : A link
note on link #red: note that is red

Dummy --> Foo2 : Another link
note right on link #blue
  this is my note on right link
  and in blue
end note

@enduml

## 추상 클래스(Abstract class)와 인터페이스(Interface)

추상 클래스를 선언하려면 `abstract`나 `abstract class` 키워드를 사용하며, 추상 클래스는 *italic*으로 표시됩니다. 

`interface`, `annotation`, `enum`과 같은 키워드도 사용가능 합니다.

```
@startuml

abstract class AbstractList
abstract AbstractCollection
interface List
interface Collection

List <|-- AbstractList
Collection <|-- AbstractCollection

Collection <|- List
AbstractCollection <|- AbstractList
AbstractList <|-- ArrayList

class ArrayList {
  Object[] elementData
  size()
}

enum TimeUnit {
  DAYS
  HOURS
  MINUTES
}

annotation SuppressWarnings

@enduml
```

@startuml
description - "enum, class and interface"
abstract class AbstractList
abstract AbstractCollection
interface List
interface Collection

List <|-- AbstractList
Collection <|-- AbstractCollection

Collection <|- List
AbstractCollection <|- AbstractList
AbstractList <|-- ArrayList

class ArrayList {
  Object[] elementData
  size()
}

enum TimeUnit {
  DAYS
  HOURS
  MINUTES
}

annotation SuppressWarnings

@enduml

## 비 문자(non-letters) 사용하기

클래스(혹은 enum)에 non-letter를 사용하려면 다음 방식 중 한가지를 사용합니다.

* 클래스 정의에서 `as` 키워드를 사용
* 클래스 명을 쌍따옴표`""`로 둘러쌈

```
@startuml
class "This is my class" as class1
class class2 as "It works this way too"

class2 *-- "foo/dummy" : use
@enduml
```

@startuml
description - "long class names"
class "This is my class" as class1
class class2 as "It works this way too"

class2 *-- "foo/dummy" : use
@enduml

## 속성이나 메소드등을 숨기기

`hide/show` 커맨드로 클래스의 표시를 전환 가능합니다. 기본 명령은 `hide empty members`이며, 이것은 속성과 메소드가 모두 비어 있다면 속성과 메소드 영역을 표시하지 않습니다.

`show/hide` 명령 뒤에는 `empty members` 대신에 다음과 같은 옵션을 사용할 수 있습니다:

* `empty fields` 또는 `empty attributes`: 변수 영역이 비어있는 경우 선택
* `empty methods`: 메소드 영역이 비어있는 경우 선택
* `fields`, `attributes`: 변수 영역의 내용 유무와 상관없이 선택
* `methods`: 메소드 영역의 내용 유무와 상관없이 선택
* `members`: 변수영역과 메소드 영역 모두를 내용 유무와 상관없이 선택
* `circle`: 클래스명 앞의 원을 선택
* `stereotype`: 스테레오타입을 선택

또한, `show/hide` 키워드 다음에 다음과 같은 옵션도 사용할 수 있습니다:

* `class`
* `interface`
* `enum`
* `<<foo1>>`: foo1 스테레오타입을 가지는 클래스들
* 존재하는 클래스 명

다양한 규칙과 예외를 정의하기 위해서 여러개의 show/hide 명령을 사용할 수 있습니다.

```
@startuml

class Dummy1 {
  +myMethods()
}

class Dummy2 {
  +hiddenMethod()
}

class Dummy3 <<Serializable>> {
	String name
}

hide members
hide <<Serializable>> circle
show Dummy1 methods
show <<Serializable>> fields

@enduml
```

@startuml
description - "controlling element visibility"
class Dummy1 {
  +myMethods()
}

class Dummy2 {
  +hiddenMethod()
}

class Dummy3 <<Serializable>> {
  String name
}

hide members
hide <<Serializable>> circle
show Dummy1 methods
show <<Serializable>> fields

@enduml

## Hide classes

You can also use the show/hide commands to hide classes.
This may be useful if you define a large !included file, and if you want to hide come classes after file inclusion.

@startuml

class Foo1
class Foo2

Foo2 *-- Foo1

hide Foo2

@enduml
hiding entire class
Use generics

You can also use bracket < and > to define generics usage in a class.
@startuml

class Foo<? extends Element> {
  int size()
}
Foo *- Element

@enduml
class diagrams with generic
Specific Spot

Usually, a spotted character (C, I, E or A) is used for classes, interface, enum and abstract classes.
But you can define your own spot for a class when you define the stereotype, adding a single character and a color, like in this example:

@startuml

class System << (S,#FF7700) Singleton >>
class Date << (D,orchid) >>
@enduml
spot on class
Packages

You can define a package using the package keyword, and optionally declare a background color for your package (Using a html color code or name).
Note that package definitions can be nested.

@startuml

package "Classic Collections" #DDDDDD {
  Object <|-- ArrayList
}

package net.sourceforge.plantuml {
  Object <|-- Demo1
  Demo1 *- Demo2
}

@enduml
packages and classes
Packages style

There are different styles available for packages.
You can specify them either by setting a default style with the command : skinparam packageStyle, or by using a stereotype on the package:

@startuml
scale 750 width
package foo1 <<Node>> {
  class Class1
}

package foo2 <<Rect>> {
  class Class2
}

package foo3 <<Folder>> {
  class Class3
}

package foo4 <<Frame>> {
  class Class4
}

package foo5 <<Cloud>> {
  class Class5
}

package foo6 <<Database>> {
  class Class6
}

@enduml
different package style

You can also define links between packages, like in the following example:
@startuml

skinparam packageStyle rect

package foo1.foo2 {
}

package foo1.foo2.foo3 {
  class Object
}

foo1.foo2 +-- foo1.foo2.foo3

@enduml
link between packages
Namespaces

In packages, the name of a class is the unique identifier of this class. It means that you cannot have two classes with the very same name in different packages.
In that case, you should use namespaces instead of packages.

You can refer to classes from other namespaces by fully qualify them. Classes from the default namespace are qualified with a starting dot.

Note that you don't have to explicitly create namespace : a fully qualified class is automatically put in the right namespace.

@startuml

class BaseClass

namespace net.dummy #DDDDDD {
    .BaseClass <|-- Person
    Meeting o-- Person
    
    .BaseClass <|- Meeting
}

namespace net.foo {
  net.dummy.Person  <|- Person
  .BaseClass <|-- Person

  net.dummy.Meeting o-- Person
}

BaseClass <|-- net.unused.Person

@enduml
namespace examples
Automatic namespace creation

You can define another separator (other than the dot) using the command : set namespaceSeparator ???.
@startuml

set namespaceSeparator ::
class X1::X2::foo {
  some info
}

@enduml
namespace separator
You can disable automatic package creation using the command set namespaceSeparator none.
@startuml

set namespaceSeparator none
class X1.X2.foo {
  some info
}

@enduml
namespace separator disabled
Lollipop interface

You can also define lollipops interface on classes, using the following syntax:
bar ()- foo
bar ()-- foo
foo -() bar
@startuml
class foo
bar ()- foo
@enduml
lollipop interface
Changing arrows direction

By default, links between classes have two dashes -- and are vertically oriented. It is possible to use horizontal link by putting a single dash (or dot) like this:
@startuml
Room o- Student
Room *-- Chair
@enduml
controlling arrows direction
You can also change directions by reversing the link:
@startuml
Student -o Room
Chair --* Room
@enduml
changing arrows direction
It is also possible to change arrow direction by adding left, right, up or down keywords inside the arrow:
@startuml
foo -left-> dummyLeft 
foo -right-> dummyRight 
foo -up-> dummyUp 
foo -down-> dummyDown
@enduml
left right up and down example
You can shorten the arrow by using only the first character of the direction (for example, -d- instead of -down-) or the two first characters (-do-).
Please note that you should not abuse this functionality : Graphviz gives usually good results without tweaking.

Title the diagram

The title keyword is used to put a title.
You can use title and end title keywords for a longer title, as in sequence diagrams.

@startuml

title Simple <b>example</b>\nof title 
Object <|-- ArrayList

@enduml
title example
Legend the diagram

The legend and end legend are keywords is used to put a legend.
You can optionally specify to have left, right or center alignment for the legend.

@startuml

Object <|- ArrayList

legend right
  <b>Object</b> and <b>ArrayList</b>
  are simple class
endlegend

@enduml
legend on diagram
Association classes

You can define association class after that a relation has been defined between two classes, like in this example:
@startuml
class Student {
  Name
}
Student "0..*" - "1..*" Course
(Student, Course) .. Enrollment

class Enrollment {
  drop()
  cancel()
}
@enduml
association classes
You can define it in another direction:
@startuml
class Student {
  Name
}
Student "0..*" -- "1..*" Course
(Student, Course) . Enrollment

class Enrollment {
  drop()
  cancel()
}
@enduml
association classes
Skinparam

You can use the skinparam command to change colors and fonts for the drawing.
You can use this command :

In the diagram definition, like any other commands,
In an included file,
In a configuration file, provided in the command line or the ANT task.
@startuml

skinparam class {
	BackgroundColor PaleGreen
	ArrowColor SeaGreen
	BorderColor SpringGreen
}
skinparam stereotypeCBackgroundColor YellowGreen

Class01 "1" *-- "many" Class02 : contains

Class03 o-- Class04 : aggregation

@enduml
changing fonts and colors with skin
Skinned Stereotypes

You can define specific color and fonts for stereotyped classes.
@startuml

skinparam class {
	BackgroundColor PaleGreen
	ArrowColor SeaGreen
	BorderColor SpringGreen
	BackgroundColor<<Foo>> Wheat
	BorderColor<<Foo>> Tomato
}
skinparam stereotypeCBackgroundColor YellowGreen
skinparam stereotypeCBackgroundColor<< Foo >> DimGray

Class01 <<Foo>>
Class03 <<Foo>>
Class01 "1" *-- "many" Class02 : contains

Class03 o-- Class04 : aggregation

@enduml
skin and stereotypes
Color gradient

It's possible to declare individual color for classes or note using the # notation. 
You can use either standard color name or RGB code.
You can also use color gradient in background, with the following syntax: two colors names separated either by:

|,
/,
\,
or -
depending the direction of the gradient. For example, you could have:
@startuml

skinparam backgroundcolor AntiqueWhite/Gold
skinparam classBackgroundColor Wheat|CornflowerBlue

class Foo #red-green
note left of Foo #blue\9932CC
  this is my
  note on this class
end note

package example #GreenYellow/LightGoldenRodYellow {
  class Dummy
}

@enduml
color gradient
Help on layout

Sometimes, the default layout is not perfect...
You can use together keyword to group some classes together : the layout engine will try to group them (as if they were in the same package).

You can also use hidden links to force the layout.

@startuml

class Bar1
class Bar2
together {
  class Together1
  class Together2
  class Together3
}
Together1 - Together2
Together2 - Together3
Together2 -[hidden]--> Bar1
Bar1 -[hidden]> Bar2


@enduml
layout example
Splitting large files

Sometimes, you will get some very large image files.
You can use the "page (hpages)x(vpages)" command to split the generated image into several files :

hpages is a number that indicated the number of horizontal pages, and vpages is a number that indicated the number of vertical pages.

@startuml
' Split into 4 pages
page 2x2

class BaseClass

namespace net.dummy #DDDDDD {
    .BaseClass <|-- Person
    Meeting o-- Person
    
    .BaseClass <|- Meeting

}

namespace net.foo {
  net.dummy.Person  <|- Person
  .BaseClass <|-- Person

  net.dummy.Meeting o-- Person
}

BaseClass <|-- net.unused.Person
@enduml
	